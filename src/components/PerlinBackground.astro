---
// Variables réglables pour le bruit de Perlin
const { 
  scale = 0.01,          // Échelle du bruit (valeurs plus petites = motifs plus grands)
  speed = 0.001,         // Vitesse d'animation
  octaves = 3,           // Nombre de couches de bruit
  persistence = 0.5,     // Influence de chaque octave
  lacunarity = 2.0,      // Fréquence entre les octaves
  hue = 230,             // Teinte de base (0-360)
  saturation = 60,       // Saturation (0-100)
  lightness = 30,        // Luminosité (0-100) 
  contrast = 1.2         // Contraste du bruit
} = Astro.props;
---

<div id="perlin-background" class="fixed top-0 left-0 w-full h-full -z-10"></div>

<script is:inline define:vars={{ scale, speed, octaves, persistence, lacunarity, hue, saturation, lightness, contrast }}>
  // Implémentation de bruit de Perlin basée sur l'algorithme amélioré de Stefan Gustavson
  class PerlinNoise {
    constructor() {
      this.permutation = new Uint8Array(512);
      this.seed(Math.random());
    }

    seed(seed) {
      if (seed > 0 && seed < 1) {
        seed *= 65536;
      }

      seed = Math.floor(seed);
      if (seed < 256) {
        seed |= seed << 8;
      }

      const p = new Uint8Array(256);
      for (let i = 0; i < 256; i++) {
        p[i] = i;
      }

      // Mélanger le tableau en utilisant la graine
      let n = 256;
      let q;
      while (n > 1) {
        n--;
        seed = (seed * 16807) % 2147483647;
        q = Math.floor((seed / 2147483647) * n);
        [p[n], p[q]] = [p[q], p[n]];
      }

      // Étendre le tableau à 512 éléments
      for (let i = 0; i < 512; i++) {
        this.permutation[i] = p[i & 255];
      }
    }

    // Fonction de fondu
    fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    // Produit scalaire de vecteurs de gradient
    grad(hash, x, y, z) {
      const h = hash & 15;
      const u = h < 8 ? x : y;
      const v = h < 4 ? y : h == 12 || h == 14 ? x : z;
      return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    }

    // Calcul de bruit 3D
    noise3D(x, y, z) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      const Z = Math.floor(z) & 255;

      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);

      const u = this.fade(x);
      const v = this.fade(y);
      const w = this.fade(z);

      const A = this.permutation[X] + Y;
      const AA = this.permutation[A] + Z;
      const AB = this.permutation[A + 1] + Z;
      const B = this.permutation[X + 1] + Y;
      const BA = this.permutation[B] + Z;
      const BB = this.permutation[B + 1] + Z;

      const lerp = (a, b, t) => a + t * (b - a);

      return lerp(
        lerp(
          lerp(this.grad(this.permutation[AA], x, y, z),
               this.grad(this.permutation[BA], x - 1, y, z), u),
          lerp(this.grad(this.permutation[AB], x, y - 1, z),
               this.grad(this.permutation[BB], x - 1, y - 1, z), u), v),
        lerp(
          lerp(this.grad(this.permutation[AA + 1], x, y, z - 1),
               this.grad(this.permutation[BA + 1], x - 1, y, z - 1), u),
          lerp(this.grad(this.permutation[AB + 1], x, y - 1, z - 1),
               this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1), u), v),
        w
      );
    }

    // Bruit fractionnaire (FBM - Fractional Brownian Motion)
    fbm(x, y, z, octaves, persistence, lacunarity) {
      let total = 0;
      let frequency = 1;
      let amplitude = 1;
      let maxValue = 0;

      for (let i = 0; i < octaves; i++) {
        total += this.noise3D(x * frequency, y * frequency, z * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
      }

      return total / maxValue;
    }
  }

  // Initialisation et rendu
  function initPerlinBackground() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const perlin = new PerlinNoise();
    const background = document.getElementById('perlin-background');
    
    if (!background) {
      console.error('Perlin background element not found');
      return;
    }

    // Mettre à jour la taille du canvas pour qu'elle corresponde à l'écran
    function updateCanvasSize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // Ajouter le canvas au DOM
    background.appendChild(canvas);
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    
    // Configuration initiale
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);

    // Animation
    let time = 0;
    function draw() {
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;

      // Génération du bruit pour chaque pixel
      // Optimisation: diminuer la résolution pour améliorer les performances
      const pixelSize = 2; // Taille des "macro-pixels" (réduit la charge de calcul)
      for (let x = 0; x < canvas.width; x += pixelSize) {
        for (let y = 0; y < canvas.height; y += pixelSize) {
          // Calculer la valeur de bruit
          const noiseValue = perlin.fbm(
            x * scale,
            y * scale,
            time,
            octaves,
            persistence,
            lacunarity
          );
          
          // Appliquer le contraste
          let value = (noiseValue - 0.5) * contrast + 0.5;
          value = Math.max(0, Math.min(1, value));
          
          // Créer une couleur HSL basée sur la valeur de bruit
          const h = hue;
          const s = saturation;
          const l = Math.floor(lightness + value * 15);
          
          // Convertir HSL en RGB
          const c = (1 - Math.abs(2 * l / 100 - 1)) * s / 100;
          const x = c * (1 - Math.abs((h / 60) % 2 - 1));
          const m = l / 100 - c / 2;
          
          let r, g, b;
          
          if (h < 60) {
            [r, g, b] = [c, x, 0];
          } else if (h < 120) {
            [r, g, b] = [x, c, 0];
          } else if (h < 180) {
            [r, g, b] = [0, c, x];
          } else if (h < 240) {
            [r, g, b] = [0, x, c];
          } else if (h < 300) {
            [r, g, b] = [x, 0, c];
          } else {
            [r, g, b] = [c, 0, x];
          }
          
          // Conversion finale en valeurs RGB 0-255
          const index = (y * canvas.width + x) * 4;
          const r255 = Math.floor((r + m) * 255);
          const g255 = Math.floor((g + m) * 255);
          const b255 = Math.floor((b + m) * 255);
          
          // Remplir le bloc de pixels (pour l'optimisation)
          for (let px = 0; px < pixelSize && x + px < canvas.width; px++) {
            for (let py = 0; py < pixelSize && y + py < canvas.height; py++) {
              const idx = ((y + py) * canvas.width + (x + px)) * 4;
              data[idx] = r255;
              data[idx + 1] = g255;
              data[idx + 2] = b255;
              data[idx + 3] = 255; // Alpha
            }
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);
      time += speed;
      requestAnimationFrame(draw);
    }

    draw();
  }
  
  // Exécuter quand le DOM est chargé
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPerlinBackground);
  } else {
    initPerlinBackground();
  }
</script>