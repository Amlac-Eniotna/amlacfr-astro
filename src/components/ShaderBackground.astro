---
const { resolution = 80, speed = 2.0, iterations = 5 } = Astro.props;
---

<canvas id="shader-canvas" class="shader-background"></canvas>

<style>
  .shader-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -5;
  }
</style>

<script define:vars={{ resolution, speed, iterations }}>
  document.addEventListener("DOMContentLoaded", function () {
    const canvas = document.getElementById("shader-canvas");
    if (!canvas) {
      console.error("Canvas not found!");
      return;
    }

    // Initialiser WebGL
    const gl =
      canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if (!gl) {
      console.error("WebGL not supported");
      return;
    }

    // Redimensionner le canvas
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    // Code du vertex shader
    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    // Code du fragment shader
    const fragmentShaderSource = `
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;

      vec4 simplex_noise_3d_permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
      vec4 simplex_noise_3d_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
      float simplex_noise_3d(vec3 v) { 
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        // First corner
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;
        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        //  x0 = x0 - 0. + 0.0 * C 
        vec3 x1 = x0 - i1 + 1.0 * C.xxx;
        vec3 x2 = x0 - i2 + 2.0 * C.xxx;
        vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
        // Permutations
        i = mod(i, 289.0 ); 
        vec4 p = simplex_noise_3d_permute( simplex_noise_3d_permute( simplex_noise_3d_permute( 
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        // Gradients
        // ( N*N points uniformly over a square, mapped onto an octahedron.)
        float n_ = 1.0/7.0; // N=7
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        //Normalise gradients
        vec4 norm = simplex_noise_3d_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                  dot(p2,x2), dot(p3,x3) ) );
      }
    
      float fractal_simplex_noise_3d(vec3 p, int iterations) {
        float total = 0.0;
        float divide = 0.0;
        float scale = 1.0;
        for (int iter = 0; iter < 10; iter++) {
            if (iter >= iterations) {
                break;
            }

            total += simplex_noise_3d(p / scale) * scale;
            divide += scale;

            scale *= 0.5;
        }
        return total / divide;
      }
  
      float value(vec3 position) {
        return fractal_simplex_noise_3d(position / 20.0, int(${iterations}.0)) + 0.5;
      }
  
      float halftone(vec2 position, vec2 offset) {
        float valueAt = value(vec3(position, u_time * float(${speed}.0)));
    
        vec2 positionInCell = fract(position + offset);
    
        positionInCell.x = 0.5 - abs(positionInCell.x - 0.5);
        positionInCell.y = 0.5 - abs(positionInCell.y - 0.5);
    
        float d1 = distance(positionInCell, vec2(0.0, 0.0));
        float d2 = 1.0 - distance(positionInCell, vec2(0.5, 0.5));

        float threshold = positionInCell.x + positionInCell.y;
  
        if (threshold < 0.5) {
          float t2 = threshold * 2.0;
          t2 = 1.0 - (t2 * t2 * t2 * t2 * t2 * t2);
          threshold = threshold * (1.0 - t2) + d1 * t2;
        } else {
          float t2 = (0.5 - threshold) * 2.0;
          t2 = 1.0 - (t2 * t2 * t2 * t2 * t2 * t2);
          threshold = threshold * (1.0 - t2) + d2 * t2;
        }
    
        valueAt = (threshold - valueAt) * 5.0 + 0.5;
    
        if (valueAt < 0.0) {
          return 0.0;
        }
    
        if (valueAt > 1.0) {
          return 1.0;
        }
  
        return valueAt;
      }
  
      const float resolution = float(${resolution}.0);
  
      void main() {
        vec2 position = gl_FragCoord.xy / u_resolution.xy * resolution;
        gl_FragColor = vec4(
          halftone(position, vec2(0.0, 0.0)),
          halftone(position, vec2(0.5, 0.25)),
          halftone(position, vec2(1.0, 0.5)),
          1.0
        );
      }
    `;

    // Créer et compiler les shaders
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(
          "Erreur de compilation du shader:",
          gl.getShaderInfoLog(shader),
        );
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(
      gl,
      gl.FRAGMENT_SHADER,
      fragmentShaderSource,
    );

    // Créer et lier le programme shader
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(
        "Erreur de liaison du programme shader:",
        gl.getProgramInfoLog(program),
      );
      return;
    }

    gl.useProgram(program);

    // Créer et lier le buffer pour les positions des sommets
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // Définir un rectangle qui couvre tout l'écran
    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    // Lier les attributs du vertex shader
    const positionLocation = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // Obtenir les emplacements des uniforms
    const timeLocation = gl.getUniformLocation(program, "u_time");
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");

    // Boucle de rendu
    let time = 0;
    function render() {
      // Mettre à jour le temps
      time += 0.01;

      // Définir les uniforms
      gl.uniform1f(timeLocation, time);
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

      // Dessiner
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Continuer l'animation
      requestAnimationFrame(render);
    }

    render();
  });

  // Exécuter immédiatement si le DOM est déjà chargé
  if (
    document.readyState === "interactive" ||
    document.readyState === "complete"
  ) {
    const event = new Event("DOMContentLoaded");
    document.dispatchEvent(event);
  }
</script>
